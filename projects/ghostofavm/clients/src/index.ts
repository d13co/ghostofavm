import { AlgorandClient } from '@algorandfoundation/algokit-utils'
import { getABIDecodedValue } from '@algorandfoundation/algokit-utils/types/app-arc56'
import { CommonAppCallParams, RawSimulateOptions } from '@algorandfoundation/algokit-utils/types/composer'
import { makeEmptyTransactionSigner, Transaction } from 'algosdk'
import { GhostofavmClient, GhostofavmComposer, GhostofavmFactory, GhostofavmTypes } from './generated/GhostofavmClient'

const emptySigner = makeEmptyTransactionSigner()

type ExtraMethodCallArgs = Omit<CommonAppCallParams, 'appId' | 'sender' | 'method' | 'args' | 'onComplete'>

type Methods = GhostofavmTypes['methods']

class GhostBase {
  public algorand: AlgorandClient
  public readerAccount = 'A7NMWS3NT3IUDMLVO26ULGXGIIOUQ3ND2TXSER6EBGRZNOBOUIQXHIBGDE' // non-mainnet fee sink
  public factory: GhostofavmFactory
  private client: GhostofavmClient

  constructor({ algorand, readerAccount }: { algorand: AlgorandClient; readerAccount?: string }) {
    this.algorand = algorand
    if (readerAccount) this.readerAccount = readerAccount
    this.factory = this.algorand.client.getTypedAppFactory(GhostofavmFactory, {
      defaultSender: this.readerAccount,
    })
    this.client = this.factory.getAppClientById({ appId: 0n })
  }

  protected async execute<T>({
    transactions,
    selector,
    extraSimulateArgs,
  }: {
    transactions: Transaction[]
    selector: string
    extraSimulateArgs?: RawSimulateOptions
  }): Promise<T[]> {
    const methodName = selector.slice(0, selector.indexOf('('))

    let builder: GhostofavmComposer<any> = this.client.newGroup()

    for (const txn of transactions) {
      builder = builder.addTransaction(txn, emptySigner)
    }

    const { confirmations } = await builder.simulate({
      extraOpcodeBudget: 170_000,
      allowMoreLogging: true,
      allowEmptySignatures: true,
      allowUnnamedResources: true,
      ...extraSimulateArgs,
    })

    // collect logs from multiple, future support for arg splitting when > 2KB
    const logs = confirmations.flatMap(({ logs }, i) => {
      if (!logs) throw new Error(`logs were not returned from simulate txn ${i}. this should never happen`)
      return logs.slice(0, -1)
    })

    const specRetObj = this.client.appSpec.methods.find(({ name }) => name === methodName)?.returns
    if (!specRetObj) throw new Error('Method not found in app spec')

    const retTypeStr = specRetObj.struct ?? specRetObj.type
    const retData: T[] = []

    for (let i = 0; i < logs.length; i++) {
      retData.push(getABIDecodedValue(new Uint8Array(logs[i]), retTypeStr, this.factory.appSpec.structs) as T)
    }

    return retData
  }
}

// to be autogenerated

export class GhostofavmSDK extends GhostBase {
  constructor(args: ConstructorParameters<typeof GhostBase>[0]) {
    super(args)
  }

  async getBlkData(
    args: Methods['getBlkData']['argsObj'],
    extraMethodCallArgs?: ExtraMethodCallArgs,
    extraSimulateArgs?: RawSimulateOptions,
  ): Promise<Methods['getBlkData']['returns'][]> {
    const { transactions } = await this.factory.createTransaction.create.getBlkData({
      args,
      ...extraMethodCallArgs,
    })
    return this.execute({
      transactions,
      selector: 'getBlkData(uint64,uint64)(uint64,uint64,uint64,address)',
      extraSimulateArgs,
    })
  }

  async blkProposers(
    args: Methods['blkProposer']['argsObj'],
    extraMethodCallArgs?: ExtraMethodCallArgs,
    extraSimulateArgs?: RawSimulateOptions,
  ): Promise<Methods['blkProposer']['returns'][]> {
    const { transactions } = await this.factory.createTransaction.create.blkProposer({
      args,
      ...extraMethodCallArgs,
    })
    const selector = 'blkProposer(uint64,uint64)address'
    return this.execute({ transactions, selector, extraSimulateArgs })
  }

  async blkTimestamp(
    args: Methods['blkTimestamp']['argsObj'],
    extraMethodCallArgs?: ExtraMethodCallArgs,
    extraSimulateArgs?: RawSimulateOptions,
  ): Promise<Methods['blkTimestamp']['returns'][]> {
    const { transactions } = await this.factory.createTransaction.create.blkTimestamp({
      args,
      ...extraMethodCallArgs,
    })
    const selector = 'blkTimestamp(uint64,uint64)uint64'
    return this.execute({ transactions, selector, extraSimulateArgs })
  }

  async acctBalanceData(
    args: Methods['acctBalanceData']['argsObj'],
    extraMethodCallArgs?: ExtraMethodCallArgs,
    extraSimulateArgs?: RawSimulateOptions,
  ): Promise<Methods['acctBalanceData']['returns'][]> {
    const selector = 'blkTimestamp(uint64,uint64)uint64'
    const { transactions } = await this.factory.createTransaction.create.acctBalanceData({
      args,
      ...extraMethodCallArgs,
    })
    return this.execute({ transactions, selector, extraSimulateArgs })
  }
}
