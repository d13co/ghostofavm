import { AlgorandClient } from '@algorandfoundation/algokit-utils'
import { getABIDecodedValue } from '@algorandfoundation/algokit-utils/types/app-arc56'
import { CommonAppCallParams, RawSimulateOptions } from '@algorandfoundation/algokit-utils/types/composer'
import { makeEmptyTransactionSigner, Transaction } from 'algosdk'
import { {{ARC56_NAME}}Client, {{ARC56_NAME}}Composer, {{ARC56_NAME}}Factory, {{ARC56_NAME}}Types } from './generated/{{ARC56_NAME}}Client'

const emptySigner = makeEmptyTransactionSigner()

type ExtraMethodCallArgs = Omit<CommonAppCallParams, 'appId' | 'sender' | 'method' | 'args' | 'onComplete'>

type Methods = {{ARC56_NAME}}Types['methods']

class GhostBase {
  public algorand: AlgorandClient
  public readerAccount = 'A7NMWS3NT3IUDMLVO26ULGXGIIOUQ3ND2TXSER6EBGRZNOBOUIQXHIBGDE' // non-mainnet fee sink
  public factory: {{ARC56_NAME}}Factory
  private client: {{ARC56_NAME}}Client

  constructor({ algorand, readerAccount }: { algorand: AlgorandClient; readerAccount?: string }) {
    this.algorand = algorand
    if (readerAccount) this.readerAccount = readerAccount
    this.factory = this.algorand.client.getTypedAppFactory({{ARC56_NAME}}Factory, {
      defaultSender: this.readerAccount,
    })
    this.client = this.factory.getAppClientById({ appId: 0n })
  }

  protected async execute<T>({
    transactions,
    signature,
    extraSimulateArgs,
  }: {
    transactions: Transaction[]
    signature: string
    extraSimulateArgs?: RawSimulateOptions
  }): Promise<T[]> {
    const methodName = signature.slice(0, signature.indexOf('('))

    let builder: {{ARC56_NAME}}Composer<any> = this.client.newGroup()

    for (const txn of transactions) {
      builder = builder.addTransaction(txn, emptySigner)
    }

    const { confirmations } = await builder.simulate({
      extraOpcodeBudget: 170_000,
      allowMoreLogging: true,
      allowEmptySignatures: true,
      allowUnnamedResources: true,
      ...extraSimulateArgs,
    })

    // collect logs from multiple, future support for arg splitting when > 2KB
    const logs = confirmations.flatMap(({ logs }, i) => {
      if (!logs) throw new Error(`logs were not returned from simulate txn ${i}. this should never happen`)
      return logs.slice(0, -1)
    })

    const specRetObj = this.client.appSpec.methods.find(({ name }) => name === methodName)?.returns
    if (!specRetObj) throw new Error('Method not found in app spec')

    const retTypeStr = specRetObj.struct ?? specRetObj.type
    const retData: T[] = []

    for (let i = 0; i < logs.length; i++) {
      retData.push(getABIDecodedValue(new Uint8Array(logs[i]), retTypeStr, this.factory.appSpec.structs) as T)
    }

    return retData
  }
}

// to be autogenerated

export class {{ARC56_NAME}}SDK extends GhostBase {
  constructor(args: ConstructorParameters<typeof GhostBase>[0]) {
    super(args)
  }

  {{METHODS}}
}
