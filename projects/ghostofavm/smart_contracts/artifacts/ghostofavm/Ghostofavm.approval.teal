#pragma version 11
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 1 0 32
    bytecblock 0x151f7c750000000000000000
    // smart_contracts/ghostofavm/contract.algo.ts:17-18
    // @contract({ avmVersion: 11 })
    // export class Ghostofavm extends Contract {
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    !
    assert
    pushbytess 0x99b7390f 0xb03694dd 0x52ee8161 0x898628b4 0xb534a352 // method "blkTimestamp(uint64,uint64)uint64", method "blkTxnCounter(uint64,uint64)uint64", method "blkProposer(uint64,uint64)address", method "getBlkData(uint64,uint64)(uint64,uint64,uint64,address)", method "acctBalanceData(address[])(address,uint64,uint64)"
    txna ApplicationArgs 0
    match blkTimestamp blkTxnCounter blkProposer getBlkData acctBalanceData
    err


// smart_contracts/ghostofavm/contract.algo.ts::Ghostofavm.blkTimestamp[routing]() -> void:
blkTimestamp:
    // smart_contracts/ghostofavm/contract.algo.ts:19
    // @abimethod({ readonly: true, onCreate: 'require' })
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    btoi
    swap

blkTimestamp_while_top@2:
    // smart_contracts/ghostofavm/contract.algo.ts:21
    // for (let round: uint64 = firstRound; round <= lastRound; round++) {
    dup
    dig 2
    <=
    bz blkTimestamp_after_while@4
    // smart_contracts/ghostofavm/contract.algo.ts:22
    // log(op.Block.blkTimestamp(round))
    dupn 2
    block BlkTimestamp
    itob
    log
    // smart_contracts/ghostofavm/contract.algo.ts:21
    // for (let round: uint64 = firstRound; round <= lastRound; round++) {
    intc_0 // 1
    +
    bury 1
    b blkTimestamp_while_top@2

blkTimestamp_after_while@4:
    // smart_contracts/ghostofavm/contract.algo.ts:19
    // @abimethod({ readonly: true, onCreate: 'require' })
    bytec_0 // 0x151f7c750000000000000000
    log
    intc_0 // 1
    return


// smart_contracts/ghostofavm/contract.algo.ts::Ghostofavm.blkTxnCounter[routing]() -> void:
blkTxnCounter:
    // smart_contracts/ghostofavm/contract.algo.ts:27
    // @abimethod({ readonly: true, onCreate: 'require' })
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    btoi
    swap

blkTxnCounter_while_top@2:
    // smart_contracts/ghostofavm/contract.algo.ts:29
    // for (let round: uint64 = firstRound; round <= lastRound; round++) {
    dup
    dig 2
    <=
    bz blkTxnCounter_after_while@4
    // smart_contracts/ghostofavm/contract.algo.ts:30
    // log(op.Block.blkTxnCounter(round))
    dupn 2
    block BlkTxnCounter
    itob
    log
    // smart_contracts/ghostofavm/contract.algo.ts:29
    // for (let round: uint64 = firstRound; round <= lastRound; round++) {
    intc_0 // 1
    +
    bury 1
    b blkTxnCounter_while_top@2

blkTxnCounter_after_while@4:
    // smart_contracts/ghostofavm/contract.algo.ts:27
    // @abimethod({ readonly: true, onCreate: 'require' })
    bytec_0 // 0x151f7c750000000000000000
    log
    intc_0 // 1
    return


// smart_contracts/ghostofavm/contract.algo.ts::Ghostofavm.blkProposer[routing]() -> void:
blkProposer:
    // smart_contracts/ghostofavm/contract.algo.ts:35
    // @abimethod({ readonly: true, onCreate: 'require' })
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    btoi
    swap

blkProposer_while_top@2:
    // smart_contracts/ghostofavm/contract.algo.ts:37
    // for (let round: uint64 = firstRound; round <= lastRound; round++) {
    dup
    dig 2
    <=
    bz blkProposer_after_while@4
    // smart_contracts/ghostofavm/contract.algo.ts:38
    // log(op.Block.blkProposer(round))
    dupn 2
    block BlkProposer
    log
    // smart_contracts/ghostofavm/contract.algo.ts:37
    // for (let round: uint64 = firstRound; round <= lastRound; round++) {
    intc_0 // 1
    +
    bury 1
    b blkProposer_while_top@2

blkProposer_after_while@4:
    // smart_contracts/ghostofavm/contract.algo.ts:35
    // @abimethod({ readonly: true, onCreate: 'require' })
    pushbytes base32(CUPXY5IAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA)
    log
    intc_0 // 1
    return


// smart_contracts/ghostofavm/contract.algo.ts::Ghostofavm.getBlkData[routing]() -> void:
getBlkData:
    // smart_contracts/ghostofavm/contract.algo.ts:43
    // @abimethod({ readonly: true, onCreate: 'require' })
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    btoi
    swap

getBlkData_while_top@2:
    // smart_contracts/ghostofavm/contract.algo.ts:45
    // for (let round: uint64 = firstRound; round <= lastRound; round++) {
    dup
    dig 2
    <=
    bz getBlkData_after_while@4
    // smart_contracts/ghostofavm/contract.algo.ts:48
    // timestamp: op.Block.blkTimestamp(round),
    dupn 2
    block BlkTimestamp
    // smart_contracts/ghostofavm/contract.algo.ts:49
    // proposer: op.Block.blkProposer(round),
    dig 1
    block BlkProposer
    // smart_contracts/ghostofavm/contract.algo.ts:50
    // txnCounter: op.Block.blkTxnCounter(round),
    dig 2
    block BlkTxnCounter
    // smart_contracts/ghostofavm/contract.algo.ts:46-51
    // const blkData: BlkData = {
    //   round,
    //   timestamp: op.Block.blkTimestamp(round),
    //   proposer: op.Block.blkProposer(round),
    //   txnCounter: op.Block.blkTxnCounter(round),
    // }
    dig 3
    itob
    uncover 3
    itob
    concat
    swap
    itob
    concat
    swap
    concat
    // smart_contracts/ghostofavm/contract.algo.ts:52
    // log(encodeArc4(blkData))
    log
    // smart_contracts/ghostofavm/contract.algo.ts:45
    // for (let round: uint64 = firstRound; round <= lastRound; round++) {
    intc_0 // 1
    +
    bury 1
    b getBlkData_while_top@2

getBlkData_after_while@4:
    // smart_contracts/ghostofavm/contract.algo.ts:43
    // @abimethod({ readonly: true, onCreate: 'require' })
    pushbytes base32(CUPXY5IAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA)
    log
    intc_0 // 1
    return


// smart_contracts/ghostofavm/contract.algo.ts::Ghostofavm.acctBalanceData[routing]() -> void:
acctBalanceData:
    // smart_contracts/ghostofavm/contract.algo.ts:57
    // @abimethod({ readonly: true, onCreate: 'require' })
    txna ApplicationArgs 1
    dup
    // smart_contracts/ghostofavm/contract.algo.ts:59
    // for (const account of accounts) {
    intc_1 // 0
    extract_uint16
    intc_1 // 0

acctBalanceData_for_header@2:
    // smart_contracts/ghostofavm/contract.algo.ts:59
    // for (const account of accounts) {
    dup
    dig 2
    <
    bz acctBalanceData_after_for@5
    dig 2
    extract 2 0
    dig 1
    dup
    cover 2
    intc_2 // 32
    *
    intc_2 // 32
    extract3 // on error: index access is out of bounds
    // smart_contracts/ghostofavm/contract.algo.ts:62
    // balance: account.balance,
    dup
    acct_params_get AcctBalance
    assert // account funded
    // smart_contracts/ghostofavm/contract.algo.ts:63
    // minBalance: account.minBalance,
    dig 1
    acct_params_get AcctMinBalance
    assert // account funded
    // smart_contracts/ghostofavm/contract.algo.ts:60-64
    // const acctBalanceData: AcctBalanceData = {
    //   address: account,
    //   balance: account.balance,
    //   minBalance: account.minBalance,
    // }
    swap
    itob
    uncover 2
    swap
    concat
    swap
    itob
    concat
    // smart_contracts/ghostofavm/contract.algo.ts:65
    // log(encodeArc4(acctBalanceData))
    log
    intc_0 // 1
    +
    bury 1
    b acctBalanceData_for_header@2

acctBalanceData_after_for@5:
    // smart_contracts/ghostofavm/contract.algo.ts:57
    // @abimethod({ readonly: true, onCreate: 'require' })
    pushbytes base32(CUPXY5IAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA)
    log
    intc_0 // 1
    return
